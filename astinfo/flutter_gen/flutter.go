package flutter_gen

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/wanjm/gos/astbasic"
	"github.com/wanjm/gos/astinfo"
)

type FlutterGen struct {
}

func NewFlutterGen() *FlutterGen {
	return &FlutterGen{}
}

func (f *FlutterGen) GenerateCode(mp *astinfo.MainProject) {
	// 1. Determine output directory
	outDir := filepath.Join(mp.CurrentProject.FilePath, "frontgen", "flutter")
	if err := os.MkdirAll(outDir, 0755); err != nil {
		fmt.Printf("Failed to create flutter gen directory: %v\n", err)
		return
	}

	// 2. Iterate over packages and structs to generate services
	for _, pkgName := range mp.SortedPacakgeNames {
		pkg := mp.Packages[pkgName]
		for _, structName := range pkg.SortedStructNames {
			s := pkg.Structs[structName]
			// Check if struct is a service (has methods marked as servlet/prpc)
			// The prompt says: // @gos type=servlet; url="/example" on struct
			// We can also check s.Comment.serverType or groupName
			if len(s.MethodManager.Server) == 0 {
				continue
			}

			// Even if struct itself isn't marked as servlet, if it has server methods, we might want to generate it?
			// Usually the struct is the receiver for methods.
			f.genService(outDir, s)
		}
	}
}

func (f *FlutterGen) genService(outDir string, s *astinfo.Struct) {
	var sb strings.Builder

	sb.WriteString("// Code generated by github.com/wanjm/gos DO NOT EDIT.\n")
	sb.WriteString("import 'package:http_method/http_method.dart';\n")
	sb.WriteString("import 'myclient.dart';\n\n")

	// Collect dependent structs to generate them in the same file or import them
	// For simplicity, we'll try to generate DTOs used in this service in the same file,
	// or assume they are basic types.
	// A better approach is to collect all DTOs and generate them, but let's look at dependencies.

	// We need to track which structs have been generated to avoid duplication if we put them in one file.
	// But if we do per-service file, we might duplicate DTOs or need a shared DTO file.
	// Given the prompt "generate flutter call code", let's put DTOs used by the service in the same file for now,
	// ignoring cross-service sharing complexity (or maybe the user wants one big file?).
	// The prompt implies a file per service logic.

	// Let's find referenced structs
	referencedStructs := make(map[string]*astinfo.Struct)

	for _, m := range s.MethodManager.Server {
		// Params
		for _, p := range m.Params {
			f.collectStructs(p.Type, referencedStructs)
		}
		// Results
		for _, r := range m.Results {
			f.collectStructs(r.Type, referencedStructs)
		}
	}

	// Generate Structs
	for _, rs := range referencedStructs {
		// Don't generate the service struct itself as a DTO unless it is used as one?
		// Usually the service struct (Hello) is just a receiver.
		if rs == s {
			continue
		}
		sb.WriteString(f.genDTO(rs))
		sb.WriteString("\n")
	}

	// Generate Interface
	serviceName := s.StructName
	if s.Comment.GroupName != "" && s.Comment.GroupName != "servlet" {
		// Use group name if reasonable, but StructName is safer for uniqueness
		// serviceName = astbasic.Capitalize(s.Comment.GroupName)
	}

	// Abstract class
	sb.WriteString(fmt.Sprintf("abstract class %sService {\n", serviceName))
	for _, m := range s.MethodManager.Server {
		respType := "void"
		if len(m.Results) > 0 {
			respType = f.mapType(m.Results[0].Type)
			// If result is object, mapType returns the name.
			// We want RespData<T?>
		}
		sb.WriteString(fmt.Sprintf("  Future<RespData<%s?>> %s(", respType, astbasic.FirstLower(m.Name)))

		// Params. Usually (Context, Request). Context is skipped.
		// Assuming 2nd param is Request.
		if len(m.Params) > 1 {
			reqType := f.mapType(m.Params[1].Type)
			sb.WriteString(fmt.Sprintf("%s data", reqType))
		}
		sb.WriteString(");\n")
	}
	sb.WriteString("}\n\n")

	// Generate Implementation
	sb.WriteString(fmt.Sprintf("class %sServiceImpl extends BaseMethod implements %sService {\n", serviceName, serviceName))
	sb.WriteString(fmt.Sprintf("  %sServiceImpl({required HttpClient client}) : super(client: client);\n", serviceName))

	for _, m := range s.MethodManager.Server {
		url := m.Comment.Url
		// Combine with struct url if needed.
		// astinfo/callable_gen/servlet.go does: path.Join(method.Receiver.Comment.Url, method.Comment.Url)
		fullUrl := strings.ReplaceAll(filepath.Join(s.Comment.Url, url), "\\", "/")

		respType := "void"
		resTypeInner := "dynamic"
		if len(m.Results) > 0 {
			respType = f.mapType(m.Results[0].Type)
			resTypeInner = respType
		}

		sb.WriteString("  @override\n")
		methodName := astbasic.FirstLower(m.Name)
		sb.WriteString(fmt.Sprintf("  Future<RespData<%s?>> %s(", respType, methodName))

		hasReq := false
		reqName := "data"
		if len(m.Params) > 1 {
			hasReq = true
			reqType := f.mapType(m.Params[1].Type)
			sb.WriteString(fmt.Sprintf("%s data", reqType))
		} else {
			// If no request param, pass empty dict?
		}
		sb.WriteString(") => getData(\n")
		if hasReq {
			sb.WriteString(fmt.Sprintf("    data: %s,\n", reqName))
		} else {
			sb.WriteString("    data: {},\n")
		}
		sb.WriteString(fmt.Sprintf("    url: \"%s\",\n", fullUrl))
		sb.WriteString("    encodeDataFunction: (RespData resp) {\n")

		// Decoding logic
		// resp.obj = HelloResponse.fromJson(resp.res);
		if resTypeInner != "void" && resTypeInner != "dynamic" {
			// Check if it's a List
			if strings.HasPrefix(resTypeInner, "List<") {
				// List decoding
				// resp.obj = (resp.res as List).map((e) => Item.fromJson(e)).toList();
				// Parsing generic list is tricky without reified types or helper.
				// For now, assume it's a DTO with fromJson
				inner := resTypeInner[5 : len(resTypeInner)-1]
				if isBasicType(inner) {
					sb.WriteString(fmt.Sprintf("      resp.obj = (resp.res as List).map((e) => e as %s).toList();\n", inner))
				} else {
					sb.WriteString(fmt.Sprintf("      resp.obj = (resp.res as List).map((e) => %s.fromJson(e)).toList();\n", inner))
				}
			} else if isBasicType(resTypeInner) {
				sb.WriteString(fmt.Sprintf("      resp.obj = resp.res as %s;\n", resTypeInner))
			} else {
				sb.WriteString(fmt.Sprintf("      resp.obj = %s.fromJson(resp.res);\n", resTypeInner))
			}
		}

		sb.WriteString("    },\n")
		sb.WriteString("  );\n")
	}
	sb.WriteString("}\n")

	// Variable definition
	sb.WriteString(fmt.Sprintf("\nvar %sService = %sServiceImpl(client: client);\n", astbasic.FirstLower(serviceName), serviceName))

	fileName := strings.ToLower(s.StructName) + ".gen.dart"
	os.WriteFile(filepath.Join(outDir, fileName), []byte(sb.String()), 0644)
}

func (f *FlutterGen) collectStructs(t astinfo.Typer, seen map[string]*astinfo.Struct) {
	t = astinfo.GetBasicType(t)
	switch v := t.(type) {
	case *astinfo.Struct:
		if _, ok := seen[v.StructName]; !ok {
			seen[v.StructName] = v
			// Recursively collect fields
			for _, field := range v.Fields {
				f.collectStructs(field.Type, seen)
			}
		}
	case *astinfo.ArrayType:
		f.collectStructs(v.Typer, seen)
	case *astinfo.PointerType:
		f.collectStructs(v.Typer, seen)
	}
}

func (f *FlutterGen) genDTO(s *astinfo.Struct) string {
	var sb strings.Builder
	// DTO class
	sb.WriteString(fmt.Sprintf("class %s extends JSONParameter {\n", s.StructName))

	// Fields
	for _, field := range s.Fields {
		dartType := f.mapType(field.Type)
		name := field.GetJsonName()

		// Default value handling?
		// "final String name;"
		sb.WriteString(fmt.Sprintf("  final %s %s;\n", dartType, name))
	}

	// Constructor
	sb.WriteString(fmt.Sprintf("\n  %s({", s.StructName))
	for _, field := range s.Fields {
		name := field.GetJsonName()
		sb.WriteString(fmt.Sprintf("required this.%s, ", name))
	}
	sb.WriteString("});\n\n")

	// toJson
	sb.WriteString("  @override\n")
	sb.WriteString("  Map<String, dynamic> toJson() {\n")
	sb.WriteString("    return {\n")
	for _, field := range s.Fields {
		name := field.GetJsonName()
		sb.WriteString(fmt.Sprintf("      \"%s\": %s,\n", name, name))
	}
	sb.WriteString("    };\n")
	sb.WriteString("  }\n\n")

	// fromJson
	sb.WriteString(fmt.Sprintf("  factory %s.fromJson(Map<String, dynamic> json) {\n", s.StructName))
	sb.WriteString(fmt.Sprintf("    return %s(\n", s.StructName))
	for _, field := range s.Fields {
		name := field.GetJsonName()
		// Handle null safety and defaults
		// "name: json['name'] ?? ''"
		dartType := f.mapType(field.Type)
		defaultValue := f.defaultValue(field.Type)

		if strings.HasPrefix(dartType, "List<") {
			// Array handling
			// json['list'] != null ? (json['list'] as List).map(...).toList() : []
			innerType := dartType[5 : len(dartType)-1]
			if isBasicType(innerType) {
				sb.WriteString(fmt.Sprintf("      %s: json['%s'] != null ? (json['%s'] as List).map((e) => e as %s).toList() : [],\n", name, name, name, innerType))
			} else {
				sb.WriteString(fmt.Sprintf("      %s: json['%s'] != null ? (json['%s'] as List).map((e) => %s.fromJson(e)).toList() : [],\n", name, name, name, innerType))
			}
		} else if isBasicType(dartType) {
			sb.WriteString(fmt.Sprintf("      %s: json['%s'] ?? %s,\n", name, name, defaultValue))
		} else {
			// Nested object
			// obj: json['obj'] != null ? Obj.fromJson(json['obj']) : Obj.empty() or ???
			// Since we use required, we need a value.
			// If field is nullable in Dart, we could return null.
			// But we defined fields as non-nullable 'final Type name'.
			// The prompt example shows: HelloResponse(json['name'] ?? '');
			// For structs, we might need a default constructor or allow null?
			// "final int loginType = 0;" in prompt.

			// For now, let's assume we can handle null if we change type to nullable or provide defaults.
			// Simplified:
			sb.WriteString(fmt.Sprintf("      %s: json['%s'] != null ? %s.fromJson(json['%s']) : %s,\n", name, name, dartType, name, defaultValue))
		}
	}
	sb.WriteString("    );\n")
	sb.WriteString("  }\n")

	sb.WriteString("}\n")
	return sb.String()
}

func (f *FlutterGen) mapType(t astinfo.Typer) string {
	t = astinfo.GetBasicType(t)
	switch v := t.(type) {
	case *astinfo.RawType:
		switch v.IDName() {
		case "string":
			return "String"
		case "int", "int32", "int64", "uint", "uint32", "uint64":
			return "int"
		case "float32", "float64":
			return "double"
		case "bool":
			return "bool"
		default:
			return "dynamic"
		}
	case *astinfo.ArrayType:
		return "List<" + f.mapType(v.Typer) + ">"
	case *astinfo.Struct:
		return v.StructName
	default:
		return "dynamic"
	}
}

func isBasicType(t string) bool {
	switch t {
	case "String", "int", "double", "bool", "dynamic":
		return true
	}
	return false
}

func (f *FlutterGen) defaultValue(t astinfo.Typer) string {
	dartType := f.mapType(t)
	if strings.HasPrefix(dartType, "List") {
		return "[]"
	}
	switch dartType {
	case "String":
		return "\"\""
	case "int":
		return "0"
	case "double":
		return "0.0"
	case "bool":
		return "false"
	default:
		// For structs, we ideally need a default instance or allow null.
		// Prompt says "final int loginType = 0;"
		// If it's a struct, we might need a factory or just throw.
		// Using "null" but casting to type might fail if type is non-nullable.
		// Let's rely on null for now and compilation errors will guide fixes if needed,
		// OR construct a dummy object if possible? No.
		// Let's assume nullable fields in DTO if it's a struct?
		// Prompt DTO fields: final String name; (non-nullable).
		return "null as " + dartType // Dangerous, but shows intent.
		// Better: maybe we should generate nullable fields for Structs?
		// The prompt example uses:
		// factory HelloResponse.fromJson(Map<String, dynamic> json) {
		//   return HelloResponse(json['name'] ?? '');
		// }
		// For structs, it doesn't show an example of nested struct null handling.
		// "8. 对于对象中为数组的，如果服务端返回为null，则初始化为空数组；"
	}
}
