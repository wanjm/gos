## 数据库代码自动生成
使用示例:当你有一个user表,有三个字段

|ID|NAME|PASSWORD|
|--|--|--|
|1|zhangsan|123456|

想查询`select * from user where name='zhangsan'`时,
只要一行代码`users, err := s.UserDal.GetAll(ctx, common.OptEq(user.C_Name, "zhangsan"))`其他配套代码都给你生成好了,是不是很方便; 而且对于mongo数据库,生成dal的调用方法完全相同,就是说上面这句话既适用mysql,又使用mongo;

## 自动生成的代码说明 
1. entity结构体,就是上面表示user的结构体
2. column,User的字段名 user.C_NAME;
3. dal的自动生成,常用的dal方法,Create,GetAll....
4. DAL对象自带@gos autogen注解,所以可以在biz中直接使用

### user说明
```
// Code generated by github.com/wanjm/gos DO NOT EDIT.
package user

// @gos tblName=user dbVariable=db
type User struct {
	ID       int32  "json:\"id\" gorm:\"column:id\""             //自增id
	Name     string "json:\"name\" gorm:\"column:name\""         //姓名
	Password string "json:\"password\" gorm:\"column:password\"" //密码
}
```
1. 自动定义驼峰格式的字段名
2. 自动生成表明的注释
3. 自动生成tblName,dbVariable注解,便于dal的生成
### column说明
```
// Code generated by github.com/wanjm/gos DO NOT EDIT.
package user
const (
	C_ID = "id"
	C_Name = "name"
	C_Password = "password"
)
```
1. 自动生成列名字段的常量
2. 查询语句中使用该字段常量,可以保证字段正确
3. 通过IDE的引用可以方便搜索在哪些地方使用
4. 假设数据库删除或修改字段,重新生成的地方可以立即发现语法错误;

### dal说明
自动生成了常用的数据库操作语句,文件名为mysql.dal.gen.go
1. Create 创建记录
2. GetAll 根据条件查询所有记录
3. GetLimitAll 根据条件查询指定数量的记录
4. GetLimitAllWithStart 从某个offset开始查询指定数量的记录
5. GetOne 根据条件查询一条记录
6. GetOneById 根据id查询一条记录
7. List 根据条件查询列表,返回**列表**和**总数**
8. Update 根据条件更新记录
9. UpdateById 根据id更新记录
10. Delete 根据条件删除记录
11. DeleteByIds 根据id列表删除记录

自动生成的代码支持mysql和mongo,提供相同的函数和参数格式, 由common模块提供了代码差异屏蔽函数
查询语句都是`(ctx context.Context, options []common.Optioner, cols ...[]string)`

### dal自动生成的代码展示
由于代码较多,附在最后

### dal额外业务代码添加
上面仅仅是自动生成的默认代码,不够用时可以自动添加代码,文件名为`user.dal.go`,这个文件名留给用户自定义用,这样是自动生成的代码叫mysql.dal.gen.go的原因
自动生成的dal提供getDB和getDBOperation两个方法,前者返回`*gorm.DB`,可以直接对接gorm的方法
其中的autogen是比较自动生成变量,Db *gorm.DB也会自动注入,详见本系列前面的4篇文章
```
// Code generated by github.com/wanjm/gos DO NOT EDIT.
.... 
// @gos autogen
type UserDal struct {
	Db *gorm.DB 
}

func (a *UserDal) getDB(ctx context.Context) *gorm.DB {
	return a.Db.WithContext(ctx).Table("user")
}
func (c *UserDal) getDBOperation(context context.Context) common.DbOperation {
    ....
}
```
common.DbOperation的用法可以参考dal自动生成等代码
### common模块提供的函数说明
为了便于使用,提供github.com/wanjm/common了供提供了Opertaion对象,提供了
1. Query 查询
2. QueryCV 带总数的查询
3. Delete 删除 
4. Update  更新
5. Create 创建
等通用方法,其中关于插叙你的条件,定义了Optioner interface,并提供了具体实现,屏蔽了mysql和mongo的区别;
1. Eq
2. Ne
3. In
4. NotIn
5. Gt
6. Gte
7. Lt
8. Lte
9. Exist


## 生成文件的目录结构
```
business/package
├── entity/   
│   ├── mysql/                       # 生成MYSQL的类
│   │   ├── student/                 # 表名
│   │   │   ├── table.gen.go/        # 表对应的ENTITY结构体
│   │   │   ├── conlumn.gen.go/      # 列名常量, 通过常量引用,避免硬编码,还可以方便IDE工具查找引用
│   │   │   ├── const.gen.go/        # 数据库常量
│   ├── mongo/                       # 生成MYSQL的类
│   │   ├── student/                 # 表名
│   │   │   ├── table.go/            # 可以手工写,或者通过配置文件配置id,然后自动生成;
│   │   │   ├── conlumn.gen.go/      # 列名常量, 从table.go中生成
│   │   │   ├── const.gen.go/        # 数据库常量
├── dal/   
│   ├── user.dal.go                  # 用户扩展自定义dal文件,直接继续添加UserDal的method即可;
│   ├── mysql.dal.gen.go             # mysql自动生成的基本函数
│   ├── mongo.dal.gen.go             # mongo自动生成的基本函数
```

## 生成的配置方式,在工程目录中配置
1. project.public.toml 存放公共公开配置,如表的记录
2. project.private.toml 存放不能提交到git的配置,如DSN

```
[[DBConfig]]
DSN="user:passwd@tcp(dbhost:3306)/dbplaso"
DBName = "DBNAME"
DBType = "mysql"

[[DBConfig.DbGenCfgs]]
OutPath = "business/package"
TableNames = ["student"]
```

## 代码生成
1. 在项目目录运行 gos -dbname all 
2. all表示生成所有的表
3. -dbname参数可以上面配置的表名


## dal代码展示
```
// Code generated by github.com/wanjm/gos DO NOT EDIT.
package dal

import (
	context "context"
	user "github.com/wan_jm/servlet_example/business/package/entity/mysql/user"
	common "github.com/wanjm/common"
	gorm "gorm.io/gorm"
)

// user
//
// @gos autogen
type UserDal struct {
	Db *gorm.DB
}

func (a *UserDal) getDB(ctx context.Context) *gorm.DB {
	return a.Db.WithContext(ctx).Table("user")
}
func (c *UserDal) getDBOperation(context context.Context) common.DbOperation {
	return common.DbOperation{
		Db:        c.Db,
		TableName: "user",
		Context:   context,
	}
}

// Create 创建
func (a *UserDal) Create(ctx context.Context, item *user.User) error {
	dbOperation := a.getDBOperation(ctx)
	err := dbOperation.Create(item)
	if err != nil {
		common.Error(ctx, "insert data to user failed", common.Err(err))
	}
	return err
}

func (a *UserDal) GetAll(ctx context.Context, options []common.Optioner, cols ...[]string) (item []*user.User, err error) {
	return a.GetLimitAll(ctx, options, 0, cols...)
}
func (a *UserDal) GetLimitAll(ctx context.Context, options []common.Optioner, count int, cols ...[]string) (item []*user.User, err error) {
	return a.GetLimitAllWithStart(ctx, options, 0, count, cols...)
}
func (a *UserDal) GetLimitAllWithStart(ctx context.Context, options []common.Optioner, start, count int, cols ...[]string) (item []*user.User, err error) {
	var colNames []string
	if len(cols) > 0 {
		colNames = cols[0]
	}
	dbOperation := a.getDBOperation(ctx)
	err = dbOperation.Query(
		&common.SqlQueryOptions{
			QueryFields:  options,
			Offset:       start,
			Limit:        count,
			SelectFields: colNames,
		},
		&item,
	)
	if err != nil {
		//添加log，打印错误日志；
		common.Error(ctx, "GetAll DB record from user failed", common.Err(err))
	}
	return
}

func (a *UserDal) GetOne(ctx context.Context, options []common.Optioner, cols ...[]string) (item *user.User, err error) {
	res, err := a.GetLimitAll(ctx, options, 1, cols...)
	if err != nil {
		return
	}
	if len(res) > 0 {
		item = res[0]
	}
	return
}

func (a *UserDal) GetOneById(ctx context.Context, id int32, cols ...[]string) (item *user.User, err error) {
	return a.GetOne(ctx, []common.Optioner{common.Eq("id", id)}, cols...)
}

func (a *UserDal) List(ctx context.Context, option []common.Optioner, pageNo, pageSize int, cols ...[]string) (list []*user.User, total int64, err error) {
	var colNames []string
	if len(cols) > 0 {
		colNames = cols[0]
	}
	dbop := a.getDBOperation(ctx)
	err = dbop.QueryCV(
		&common.SqlQueryOptions{
			QueryFields: option,
			Offset:      int(pageNo * pageSize),
			Limit:       int(pageSize),
			OrderFields: []common.OrderByParam{
				{
					Field:     "id",
					Direction: common.ASCStr,
				},
			},
			SelectFields: colNames,
		},
		&total,
		&list,
	)
	if err != nil {
		//添加log，打印错误日志；
		common.Error(ctx, "List record of user failed", common.Err(err))
	}
	return
}

// Update
func (a *UserDal) Update(ctx context.Context, options []common.Optioner, updates map[string]any) (err error) {
	op := a.getDBOperation(ctx)
	err = op.Update(&common.SqlUpdateOptions{
		QueryFields: options,
		Updates:     updates,
	})
	if err != nil {
		//添加log，打印错误日志；
		common.Error(ctx, "Update record of user failed", common.Err(err))
	}
	return
}

func (a *UserDal) UpdateById(ctx context.Context, id int32, updates map[string]any) error {
	return a.Update(ctx, []common.Optioner{common.Eq("id", id)}, updates)
}

func (a *UserDal) Delete(ctx context.Context, options []common.Optioner) error {
	op := a.getDBOperation(ctx)
	err := op.Delete(options)
	if err != nil {
		common.Error(ctx, "Delete record of user failed", common.Err(err))
	}
	return err
}

func (a *UserDal) DeleteByIds(ctx context.Context, ids []int32) error {
	return a.Delete(ctx, []common.Optioner{common.In("id", ids)})
}

```
